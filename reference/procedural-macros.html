<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Procedural Macros - DiveScript reference</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> Notation</a></li><li class="chapter-item expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> Lexical structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> Input format</a></li><li class="chapter-item expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> Whitespace</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> Tokens</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros-by-example.html"><strong aria-hidden="true">3.1.</strong> Macros by Example</a></li><li class="chapter-item expanded "><a href="procedural-macros.html" class="active"><strong aria-hidden="true">3.2.</strong> Procedural Macros</a></li></ol></li><li class="chapter-item expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crates and source files</a></li><li class="chapter-item expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> Conditional compilation</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> Items</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> Modules</a></li><li class="chapter-item expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.2.</strong> Use declarations</a></li><li class="chapter-item expanded "><a href="items/functions.html"><strong aria-hidden="true">6.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.4.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="items/structs.html"><strong aria-hidden="true">6.5.</strong> Structs</a></li><li class="chapter-item expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.6.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.7.</strong> Constant items</a></li><li class="chapter-item expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.8.</strong> Static items</a></li><li class="chapter-item expanded "><a href="items/traits.html"><strong aria-hidden="true">6.9.</strong> Traits</a></li><li class="chapter-item expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.10.</strong> Implementations</a></li><li class="chapter-item expanded "><a href="items/generics.html"><strong aria-hidden="true">6.11.</strong> Generic parameters</a></li><li class="chapter-item expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.12.</strong> Associated items</a></li></ol></li><li class="chapter-item expanded "><a href="inheritance.html"><strong aria-hidden="true">7.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">8.</strong> Serialization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DiveScript reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="procedural-macros"><a class="header" href="#procedural-macros">Procedural Macros</a></h2>
<p><em>Procedural macros</em> allow creating syntax extensions as execution of a function.
Procedural macros come in one of three flavors:</p>
<ul>
<li><a href="#function-like-procedural-macros">Function-like macros</a> - <code>custom!(...)</code></li>
<li><a href="#derive-macros">Derive macros</a> - <code>#[derive(CustomDerive)]</code></li>
<li><a href="#attribute-macros">Attribute macros</a> - <code>#[custom_attribute]</code></li>
</ul>
<p>Procedural macros allow you to run code at compile time that operates over Rust
syntax, both consuming and producing Rust syntax. You can sort of think of
procedural macros as functions from an AST to another AST.</p>
<p>Procedural macros are implemented as separate processes written in the Rust language.</p>
<p>As functions, they must either return syntax, panic, or loop endlessly. Returned
syntax either replaces or adds the syntax depending on the kind of procedural
macro. Panics are caught by the compiler and are turned into a compiler error.
Endless loops are not caught by the compiler which hangs the compiler.</p>
<p>Procedural macros run during compilation, and thus have the same resources that
the compiler has. For example, standard input, error, and output are the same
that the compiler has access to. Similarly, file access is the same.</p>
<p>Procedural macros have two ways of reporting errors. The first is to panic. The
second is to emit a <code>compile_error</code> macro invocation.</p>
<h3 id="the-ds_proc_macro-crate-for-rust"><a class="header" href="#the-ds_proc_macro-crate-for-rust">The <code>ds_proc_macro</code> crate for Rust</a></h3>
<p>Procedural macros are written in Rust by depending on the crate <code>ds_proc_macro</code>. The entry point for the Rust project is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ds_proc_macro::{TokenStream, proc_macros};

proc_macros! {
    #[proc_macro]
    fn my_function_macro(input: TokenStream) -&gt; TokenStream {
        output
    }

    #[proc_macro_attribute]
    fn my_attribute_macro(attribute: TokenStream, item: TokenStream) -&gt; TokenStream {
        output
    }

    #[proc_macro_derive]
    fn my_derive_macro(item_input: TokenStream) -&gt; TokenStream {
        // `output` is appended to module or block that the item is in.
        output
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This crate primarily contains a <a href="../proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> type. Procedural macros operate
over <em>token streams</em> instead of AST nodes, which is a far more stable interface
over time for both the compiler and for procedural macros to target. A
<em>token stream</em> is roughly equivalent to <code>Vec&lt;TokenTree&gt;</code> where a <code>TokenTree</code>
can roughly be thought of as lexical token. For example <code>foo</code> is an <code>Ident</code>
token, <code>.</code> is a <code>Punct</code> token, and <code>1.2</code> is a <code>Literal</code> token. The <code>TokenStream</code>
type, unlike <code>Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>
<p>All tokens have an associated <code>Span</code>. A <code>Span</code> is an opaque value that cannot
be modified but can be manufactured. <code>Span</code>s represent an extent of source
code within a program and are primarily used for error reporting. While you
cannot modify a <code>Span</code> itself, you can always change the <code>Span</code> <em>associated</em>
with any token, such as through getting a <code>Span</code> from another token.</p>
<h3 id="procedural-macro-hygiene"><a class="header" href="#procedural-macro-hygiene">Procedural macro hygiene</a></h3>
<p>Procedural macros are <em>unhygienic</em>. This means they behave as if the output
token stream was simply written inline to the code it's next to. This means that
it's affected by external items and also affects external imports.</p>
<p>Macro authors need to be careful to ensure their macros work in as many contexts
as possible given this limitation. This often includes using absolute paths to
items in libraries (for example, <code>::ds::option::Option</code> instead of <code>Option</code>) or
by ensuring that generated functions have names that are unlikely to clash with
other functions (like <code>__internal_foo</code> instead of <code>foo</code>).</p>
<h3 id="the-proc_macros-section"><a class="header" href="#the-proc_macros-section">The <code>proc_macros!</code> section</a></h3>
<p>A series of procedural macros are defined within the <code>proc_macros!</code> macro. It refers to a Rust project by indicating its path relative to the current source's parent directory:</p>
<pre><code class="language-ds">proc_macros! {
    lang = &quot;rust&quot;;
    path = &quot;./my_proc_macros&quot;;

    // procedural macros here...
}
</code></pre>
<h3 id="function-like-procedural-macros"><a class="header" href="#function-like-procedural-macros">Function-like procedural macros</a></h3>
<p><em>Function-like procedural macros</em> are procedural macros that are invoked using
the macro invocation operator (<code>!</code>).</p>
<p>These macros are defined by a function with the <code>proc_macro</code>
<a href="attributes.html">attribute</a> inside a <code>proc_macros!</code> section, using an empty signature.</p>
<pre><code class="language-ds">proc_macros! {
    lang = &quot;rust&quot;;
    path = &quot;./my_proc_macros&quot;;

    #[proc_macro]
    fn my_function_macro();
}
</code></pre>
<p>Function-like procedural macros may be invoked in any macro invocation
position, which includes <a href="statements.html">statements</a>, <a href="expressions.html">expressions</a>, <a href="patterns.html">patterns</a>, <a href="types.html#type-expressions">type
expressions</a>, <a href="items.html">item</a> positions, including items in <a href="items/external-blocks.html"><code>extern</code> blocks</a>, inherent
and trait <a href="items/implementations.html">implementations</a>, and <a href="items/traits.html">trait definitions</a>.</p>
<h3 id="derive-macros"><a class="header" href="#derive-macros">Derive macros</a></h3>
<p><em>Derive macros</em> define new inputs for the <a href="attributes/derive.html"><code>derive</code> attribute</a>. These macros
can create new <a href="items.html">items</a> given the token stream of a <a href="items/structs.html">struct</a> or <a href="items/enumerations.html">enum</a>.
They can also define <a href="#derive-macro-helper-attributes">derive macro helper attributes</a>.</p>
<p>Custom derive macros are defined by a function with the
<code>proc_macro_derive</code> attribute and an empty signature inside a <code>proc_macros</code> section:</p>
<pre><code class="language-ds">proc_macros! {
    lang = &quot;rust&quot;;
    path = &quot;./my_proc_macros&quot;;

    #[proc_macro_derive(DeriveMacro)]
    fn my_derive_macro();
}
</code></pre>
<h4 id="derive-macro-helper-attributes"><a class="header" href="#derive-macro-helper-attributes">Derive macro helper attributes</a></h4>
<p>Derive macros can add additional <a href="attributes.html">attributes</a> into the scope of the <a href="items.html">item</a>
they are on. Said attributes are called <em>derive macro helper attributes</em>. These
attributes are <a href="attributes.html#active-and-inert-attributes">inert</a>, and their only purpose is to be fed into the derive
macro that defined them. That said, they can be seen by all macros.</p>
<p>The way to define helper attributes is to put an <code>attributes</code> key in the
<code>proc_macro_derive</code> attribute with a comma separated list of identifiers that are
the names of the helper attributes.</p>
<p>For example, the following derive macro defines a helper attribute
<code>helper</code>, but ultimately doesn't do anything with it.</p>
<pre><code class="language-ds">proc_macros! {
    lang = &quot;rust&quot;;
    path = &quot;./my_proc_macros&quot;;

    #[proc_macro_derive(HelperAttr, attributes(helper))]
    fn derive_helper_attr();
}
</code></pre>
<p>The process:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ds_proc_macro::{TokenStream, proc_macros};

proc_macros! {
    #[proc_macro_derive]
    fn derive_helper_attr(_item_input: TokenStream) -&gt; TokenStream {
        TokenStream::new()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And then usage on the derive macro on a struct:</p>
<pre><code class="language-ds">#[derive(HelperAttr)]
struct Struct {
    #[helper] field: ()
}
</code></pre>
<h3 id="attribute-macros"><a class="header" href="#attribute-macros">Attribute macros</a></h3>
<p><em>Attribute macros</em> define new <a href="attributes.html">outer attributes</a> which can be
attached to <a href="items.html">items</a>, inherent and trait
<a href="items/implementations.html">implementations</a>, and <a href="items/traits.html">trait definitions</a>.</p>
<p>Attribute macros are defined by a function with the
<code>proc_macro_attribute</code> <a href="attributes.html">attribute</a> and an empty signature:</p>
<pre><code class="language-ds">proc_macros! {
    lang = &quot;rust&quot;;
    path = &quot;./my_proc_macros&quot;;

    #[proc_macro_attribute]
    fn attribute_macro();
}
</code></pre>
<p>The process referred by the <code>proc_macros!</code> section is based on the following Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ds_proc_macro::{TokenStream, proc_macros};

proc_macros! {
    /// # Parameters
    ///
    /// - `attribute` is the delimited token following the attribute's
    /// name, not including the outer delimiters.
    /// - `item` is the rest of the item, including other attributes
    /// on the item.
    ///
    /// # Return
    ///
    /// The returned `TokenStream` replaces the item with an
    /// arbitrary number of items.
    ///
    #[proc_macro_attribute]
    fn attribute_macro(attribute: TokenStream, item: TokenStream) -&gt; TokenStream {
        output
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="declarative-macro-tokens-and-procedural-macro-tokens"><a class="header" href="#declarative-macro-tokens-and-procedural-macro-tokens">Declarative macro tokens and procedural macro tokens</a></h3>
<p>Declarative <code>macro</code>s and procedural macros use similar, but
different definitions for tokens (or rather <a href="../proc_macro/enum.TokenTree.html"><code>TokenTree</code>s</a>.)</p>
<p>Token trees in <code>macro</code> (corresponding to <code>tt</code> matchers) are defined as</p>
<ul>
<li>Delimited groups (<code>(...)</code>, <code>{...}</code>, etc)</li>
<li>All operators supported by the language, both single-character and
multi-character ones (<code>+</code>, <code>+=</code>).
<ul>
<li>Note that this set doesn't include the single quote <code>'</code>.</li>
</ul>
</li>
<li>Literals (<code>&quot;string&quot;</code>, <code>1</code>, etc)
<ul>
<li>Note that negation (e.g. <code>-1</code>) is never a part of such literal tokens,
but a separate operator token.</li>
</ul>
</li>
<li>Identifiers, including keywords (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>Labels (<code>'ident</code>)</li>
<li>Metavariable substitutions in <code>macro</code> (e.g. <code>$my_expr</code> in
<code>macro mac { ($my_expr: expr) =&gt; { $my_expr } }</code> after the <code>mac</code>'s
expansion, which will be considered a single token tree regardless of the
passed expression)</li>
</ul>
<p>Token trees in procedural macros are defined as</p>
<ul>
<li>Delimited groups (<code>(...)</code>, <code>{...}</code>, etc)</li>
<li>All operators supported by the language, both single-character and
multi-character ones (<code>+</code>, <code>+=</code>).</li>
<li>Literals (<code>&quot;string&quot;</code>, <code>1</code>, etc)
<ul>
<li>Negation (e.g. <code>-1</code>) is supported as a part of integer
and floating point literals.</li>
</ul>
</li>
<li>Identifiers, including keywords (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li>
<li>Labels</li>
</ul>
<p>Mismatches between these two definitions are accounted for when token streams
are passed to and from procedural macros. <br />
Note that the conversions below may happen lazily, so they might not happen if
the tokens are not actually inspected.</p>
<p>When passed to a proc-macro</p>
<ul>
<li>All multi-character operators are broken into single characters.</li>
<li>All metavariable substitutions are represented as their underlying token
streams.
<ul>
<li>Such token streams may be wrapped into delimited groups (<a href="../proc_macro/struct.Group.html"><code>Group</code></a>) with
implicit delimiters (<code>Delimiter::None</code>) when it's necessary for
preserving parsing priorities.</li>
<li><code>tt</code> and <code>ident</code> substitutions are never wrapped into such groups and
always represented as their underlying token trees.</li>
</ul>
</li>
</ul>
<p>When emitted from a proc macro</p>
<ul>
<li>Negative literals are converted into two tokens (the <code>-</code> and the literal)
possibly wrapped into a delimited group (<a href="../proc_macro/struct.Group.html"><code>Group</code></a>) with implicit delimiters
(<code>Delimiter::None</code>) when it's necessary for preserving parsing priorities.</li>
</ul>
<p>Note that neither declarative nor procedural macros support doc comment tokens
(e.g. <code>/// Doc</code>), so they are always converted to token streams representing
their equivalent <code>#[doc = r&quot;str&quot;]</code> attributes when passed to macros.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros-by-example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="crates-and-source-files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros-by-example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="crates-and-source-files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
