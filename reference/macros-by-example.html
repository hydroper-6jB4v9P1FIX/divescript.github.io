<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macros by Example - DiveScript reference</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="notation.html"><strong aria-hidden="true">1.</strong> Notation</a></li><li class="chapter-item expanded "><a href="lexical-structure.html"><strong aria-hidden="true">2.</strong> Lexical structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input-format.html"><strong aria-hidden="true">2.1.</strong> Input format</a></li><li class="chapter-item expanded "><a href="keywords.html"><strong aria-hidden="true">2.2.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="identifiers.html"><strong aria-hidden="true">2.3.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="comments.html"><strong aria-hidden="true">2.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="whitespace.html"><strong aria-hidden="true">2.5.</strong> Whitespace</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">2.6.</strong> Tokens</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">3.</strong> Macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="macros-by-example.html" class="active"><strong aria-hidden="true">3.1.</strong> Macros by Example</a></li><li class="chapter-item expanded "><a href="procedural-macros.html"><strong aria-hidden="true">3.2.</strong> Procedural Macros</a></li></ol></li><li class="chapter-item expanded "><a href="crates-and-source-files.html"><strong aria-hidden="true">4.</strong> Crates and source files</a></li><li class="chapter-item expanded "><a href="conditional-compilation.html"><strong aria-hidden="true">5.</strong> Conditional compilation</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">6.</strong> Items</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items/modules.html"><strong aria-hidden="true">6.1.</strong> Modules</a></li><li class="chapter-item expanded "><a href="items/use-declarations.html"><strong aria-hidden="true">6.2.</strong> Use declarations</a></li><li class="chapter-item expanded "><a href="items/functions.html"><strong aria-hidden="true">6.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="items/type-aliases.html"><strong aria-hidden="true">6.4.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="items/structs.html"><strong aria-hidden="true">6.5.</strong> Structs</a></li><li class="chapter-item expanded "><a href="items/enumerations.html"><strong aria-hidden="true">6.6.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="items/constant-items.html"><strong aria-hidden="true">6.7.</strong> Constant items</a></li><li class="chapter-item expanded "><a href="items/static-items.html"><strong aria-hidden="true">6.8.</strong> Static items</a></li><li class="chapter-item expanded "><a href="items/traits.html"><strong aria-hidden="true">6.9.</strong> Traits</a></li><li class="chapter-item expanded "><a href="items/implementations.html"><strong aria-hidden="true">6.10.</strong> Implementations</a></li><li class="chapter-item expanded "><a href="items/generics.html"><strong aria-hidden="true">6.11.</strong> Generic parameters</a></li><li class="chapter-item expanded "><a href="items/associated-items.html"><strong aria-hidden="true">6.12.</strong> Associated items</a></li></ol></li><li class="chapter-item expanded "><a href="inheritance.html"><strong aria-hidden="true">7.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="serialization.html"><strong aria-hidden="true">8.</strong> Serialization</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DiveScript reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="macros-by-example"><a class="header" href="#macros-by-example">Macros By Example</a></h1>
<blockquote>
<p><strong><sup>Syntax</sup></strong><br />
<em>MacroRulesDefinition</em> :<br />
   <code>macro</code> <a href="identifiers.html">IDENTIFIER</a> <em>MacroRulesDef</em></p>
<p><em>MacroRulesDef</em> :<br />
      <em>MacroMatcher</em> <code>{</code> <em>MacroTranscriber</em> <code>}</code> <br />
   | <code>{</code> <em>MacroRules</em> <code>}</code></p>
<p><em>MacroRules</em> :<br />
   <em>MacroRule</em> ( <code>,</code> <em>MacroRule</em> )<sup>*</sup> <code>,</code><sup>?</sup></p>
<p><em>MacroRule</em> :<br />
   <em>MacroMatcher</em> <code>=&gt;</code> <em>MacroTranscriber</em></p>
<p><em>MacroMatcher</em> :<br />
      <code>(</code> <em>MacroMatch</em><sup>*</sup> <code>)</code><br />
   | <code>[</code> <em>MacroMatch</em><sup>*</sup> <code>]</code><br />
   | <code>{</code> <em>MacroMatch</em><sup>*</sup> <code>}</code></p>
<p><em>MacroMatch</em> :<br />
      <a href="tokens.html"><em>Token</em></a><sub><em>except <code>$</code> and <a href="tokens.html#delimiters">delimiters</a></em></sub><br />
   | <em>MacroMatcher</em><br />
   | <code>$</code> ( <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> <sub><em>except <code>crate</code></em></sub> | <a href="identifiers.html">RAW_IDENTIFIER</a> | <code>_</code> ) <code>:</code> <em>MacroFragSpec</em><br />
   | <code>$</code> <code>(</code> <em>MacroMatch</em><sup>+</sup> <code>)</code> <em>MacroRepSep</em><sup>?</sup> <em>MacroRepOp</em></p>
<p><em>MacroFragSpec</em> :<br />
      <code>block</code> | <code>expr</code> | <code>ident</code> | <code>item</code> | <code>label</code> | <code>literal</code><br />
   | <code>meta</code> | <code>pat</code> | <code>pat_param</code> | <code>path</code> | <code>stmt</code> | <code>tt</code> | <code>ty</code> | <code>vis</code></p>
<p><em>MacroRepSep</em> :<br />
   <a href="tokens.html"><em>Token</em></a><sub><em>except <a href="tokens.html#delimiters">delimiters</a> and MacroRepOp</em></sub></p>
<p><em>MacroRepOp</em> :<br />
   <code>*</code> | <code>+</code> | <code>?</code></p>
<p><em>MacroTranscriber</em> :<br />
   <a href="macros.html"><em>DelimTokenTree</em></a></p>
</blockquote>
<p><code>macro</code> allows users to define syntax extension in a declarative way.  We
call such extensions &quot;macros by example&quot; or simply &quot;macros&quot;.</p>
<p>Each macro by example has a name, and one or more <em>rules</em>. Each rule has two
parts: a <em>matcher</em>, describing the syntax that it matches, and a <em>transcriber</em>,
describing the syntax that will replace a successfully matched invocation. Both
the matcher and the transcriber must be surrounded by delimiters. Macros can
expand to expressions, statements, items (including traits, impls, and foreign
items), types, or patterns.</p>
<h2 id="method-macro"><a class="header" href="#method-macro">Method macro</a></h2>
<p>Macros that appear within a trait or implementation are method macros. Method macros have a <code>__self</code> metavariable available, which is the instance they are called with.</p>
<pre><code class="language-ds">impl S {
    pub macro f() {
        __self.f2();
    }
}
</code></pre>
<h2 id="transcribing"><a class="header" href="#transcribing">Transcribing</a></h2>
<p>When a macro is invoked, the macro expander looks up macro invocations by name,
and tries each macro rule in turn. It transcribes the first successful match; if
this results in an error, then future matches are not tried. When matching, no
lookahead is performed; if the compiler cannot unambiguously determine how to
parse the macro invocation one token at a time, then it is an error. In the
following example, the compiler does not look ahead past the identifier to see
if the following token is a <code>)</code>, even though that would allow it to parse the
invocation unambiguously:</p>
<pre><code class="language-ds">macro ambiguity {
    ($($i:ident)* $j:ident) =&gt; { },
}

ambiguity!(error); // Error: local ambiguity
</code></pre>
<p>In both the matcher and the transcriber, the <code>$</code> token is used to invoke special
behaviours from the macro engine (described below in <a href="#metavariables">Metavariables</a> and
<a href="#repetitions">Repetitions</a>). Tokens that aren't part of such an invocation are matched and
transcribed literally, with one exception. The exception is that the outer
delimiters for the matcher will match any pair of delimiters. Thus, for
instance, the matcher <code>(())</code> will match <code>{()}</code> but not <code>{{}}</code>. The character
<code>$</code> cannot be matched or transcribed literally.</p>
<h3 id="forwarding-a-matched-fragment"><a class="header" href="#forwarding-a-matched-fragment">Forwarding a matched fragment</a></h3>
<p>When forwarding a matched fragment to another macro-by-example, matchers in
the second macro will see an opaque AST of the fragment type. The second macro
can't use literal tokens to match the fragments in the matcher, only a
fragment specifier of the same type. The <code>ident</code>, <code>label</code>, and <code>tt</code>
fragment types are an exception, and <em>can</em> be matched by literal tokens. The
following illustrates this restriction:</p>
<pre><code class="language-ds">macro foo {
    ($l:expr) =&gt; { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro bar {
    (3) =&gt; {}
}

foo!(3);
</code></pre>
<p>The following illustrates how tokens can be directly matched after matching a
<code>tt</code> fragment:</p>
<pre><code class="language-ds">// compiles OK
macro foo {
    ($l:tt) =&gt; { bar!($l); },
}

macro bar {
    (3) =&gt; {}
}

foo!(3);
</code></pre>
<h2 id="metavariables"><a class="header" href="#metavariables">Metavariables</a></h2>
<p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>fragment-specifier</em> matches a DS syntax
fragment of the kind specified and binds it to the metavariable <code>$</code><em>name</em>. Valid
fragment specifiers are:</p>
<ul>
<li><code>item</code>: an <a href="items.html"><em>Item</em></a></li>
<li><code>block</code>: a <a href="expressions/block-expr.html"><em>BlockExpression</em></a></li>
<li><code>stmt</code>: a <a href="statements.html"><em>Statement</em></a> without the trailing semicolon (except for item
statements that require semicolons)</li>
<li><code>pat_param</code>: a <a href="patterns.html"><em>PatternNoTopAlt</em></a></li>
<li><code>pat</code>: at least any <a href="patterns.html"><em>PatternNoTopAlt</em></a>, and possibly more depending on edition</li>
<li><code>expr</code>: an <a href="expressions.html"><em>Expression</em></a></li>
<li><code>ty</code>: a <a href="types.html#type-expressions"><em>Type</em></a></li>
<li><code>ident</code>: an <a href="identifiers.html">IDENTIFIER_OR_KEYWORD</a> or <a href="identifiers.html">RAW_IDENTIFIER</a></li>
<li><code>path</code>: a <a href="paths.html#paths-in-types"><em>TypePath</em></a> style path</li>
<li><code>tt</code>: a <a href="macros.html#macro-invocation"><em>TokenTree</em></a> (a single <a href="tokens.html">token</a> or tokens in matching delimiters <code>()</code>, <code>[]</code>, or <code>{}</code>)</li>
<li><code>meta</code>: an <a href="attributes.html"><em>Attr</em></a>, the contents of an attribute</li>
<li><code>label</code>: a <a href="tokens.html#loop-labels">LABEL_TOKEN</a></li>
<li><code>vis</code>: a possibly empty <a href="visibility-and-privacy.html"><em>Visibility</em></a> qualifier</li>
<li><code>literal</code>: matches <code>-</code><sup>?</sup><a href="expressions/literal-expr.html"><em>LiteralExpression</em></a></li>
</ul>
<p>In the transcriber, metavariables are referred to simply by <code>$</code><em>name</em>, since
the fragment kind is specified in the matcher. Metavariables are replaced with
the syntax element that matched them. The keyword metavariable <code>$crate</code> can be
used to refer to the current crate; see <a href="#hygiene">Hygiene</a> below. Metavariables can be
transcribed more than once or not at all.</p>
<h2 id="repetitions"><a class="header" href="#repetitions">Repetitions</a></h2>
<p>In both the matcher and transcriber, repetitions are indicated by placing the
tokens to be repeated inside <code>$(</code>…<code>)</code>, followed by a repetition operator,
optionally with a separator token between. The separator token can be any token
other than a delimiter or one of the repetition operators, but <code>;</code> and <code>,</code> are
the most common. For instance, <code>$( $i:ident ),*</code> represents any number of
identifiers separated by commas. Nested repetitions are permitted.</p>
<p>The repetition operators are:</p>
<ul>
<li><code>*</code> — indicates any number of repetitions.</li>
<li><code>+</code> — indicates any number but at least one.</li>
<li><code>?</code> — indicates an optional fragment with zero or one occurrence.</li>
</ul>
<p>Since <code>?</code> represents at most one occurrence, it cannot be used with a
separator.</p>
<p>The repeated fragment both matches and transcribes to the specified number of
the fragment, separated by the separator token. Metavariables are matched to
every repetition of their corresponding fragment. For instance, the <code>$( $i:ident ),*</code> example above matches <code>$i</code> to all of the identifiers in the list.</p>
<p>During transcription, additional restrictions apply to repetitions so that the
compiler knows how to expand them properly:</p>
<ol>
<li>A metavariable must appear in exactly the same number, kind, and nesting
order of repetitions in the transcriber as it did in the matcher. So for the
matcher <code>$( $i:ident ),*</code>, the transcribers <code>=&gt; { $i }</code>,
<code>=&gt; { $( $( $i)* )* }</code>, and <code>=&gt; { $( $i )+ }</code> are all illegal, but
<code>=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of
identifiers with a semicolon-separated list.</li>
<li>Each repetition in the transcriber must contain at least one metavariable to
decide how many times to expand it. If multiple metavariables appear in the
same repetition, they must be bound to the same number of fragments. For
instance, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code> must
bind the same number of <code>$i</code> fragments as <code>$j</code> fragments. This means that
invoking the macro with <code>(a, b, c; d, e, f)</code> is legal and expands to
<code>((a,d), (b,e), (c,f))</code>, but <code>(a, b, c; d, e)</code> is illegal because it does
not have the same number. This requirement applies to every layer of nested
repetitions.</li>
</ol>
<h2 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h2>
<p>By default, all identifiers referred to in a macro are expanded as-is, and are
looked up at the macro's invocation site. This can lead to issues if a macro
refers to an item or macro which isn't in scope at the invocation site. To
alleviate this, the <code>$crate</code> metavariable can be used at the start of a path to
force lookup to occur inside the crate defining the macro.</p>
<pre><code class="language-ds">//// Definitions in the `helper_macro` crate.
pub macro helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

pub macro helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
    helped!();
}
</code></pre>
<p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a
fully qualified module path when referring to non-macro items:</p>
<pre><code class="language-ds">pub mod inner {
    pub macro call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
</code></pre>
<p>Additionally, even though <code>$crate</code> allows a macro to refer to items within its
own crate when expanding, its use has no effect on visibility. An item or macro
referred to must still be visible from the invocation site. In the following
example, any attempt to invoke <code>call_foo!()</code> from outside its crate will fail
because <code>foo()</code> is not public.</p>
<pre><code class="language-ds">pub macro call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
</code></pre>
<h2 id="follow-set-ambiguity-restrictions"><a class="header" href="#follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</a></h2>
<p>The parser used by the macro system is reasonably powerful, but it is limited in
order to prevent ambiguity in current or future versions of the language. In
particular, in addition to the rule about ambiguous expansions, a nonterminal
matched by a metavariable must be followed by a token which has been decided can
be safely used after that kind of match.</p>
<p>As an example, a macro matcher like <code>$i:expr [ , ]</code> could in theory be accepted
in DS today, since <code>[,]</code> cannot be part of a legal expression and therefore
the parse would always be unambiguous. However, because <code>[</code> can start trailing
expressions, <code>[</code> is not a character which can safely be ruled out as coming
after an expression. If <code>[,]</code> were accepted in a later version of DS, this
matcher would become ambiguous or would misparse, breaking working code.
Matchers like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal, however, because <code>,</code> and
<code>;</code> are legal expression separators. The specific rules are:</p>
<ul>
<li><code>expr</code> and <code>stmt</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, or <code>;</code>.</li>
<li><code>pat_param</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, or <code>in</code>.</li>
<li><code>pat</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, or <code>in</code>.</li>
<li><code>path</code> and <code>ty</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>,
<code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro variable of <code>block</code>
fragment specifier.</li>
<li><code>vis</code> may only be followed by one of: <code>,</code>, an identifier other than a
non-raw <code>priv</code>, any token that can begin a type, or a metavariable with a
<code>ident</code>, <code>ty</code>, or <code>path</code> fragment specifier.</li>
<li>All other fragment specifiers have no restrictions.</li>
</ul>
<p>When repetitions are involved, then the rules apply to every possible number of
expansions, taking separators into account. This means:</p>
<ul>
<li>If the repetition includes a separator, that separator must be able to
follow the contents of the repetition.</li>
<li>If the repetition can repeat multiple times (<code>*</code> or <code>+</code>), then the contents
must be able to follow themselves.</li>
<li>The contents of the repetition must be able to follow whatever comes
before, and whatever comes after must be able to follow the contents of the
repetition.</li>
<li>If the repetition can match zero times (<code>*</code> or <code>?</code>), then whatever comes
after must be able to follow whatever comes before.</li>
</ul>
<p>For more detail, see the <a href="macro-ambiguity.html">formal specification</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="macros.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="procedural-macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="macros.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="procedural-macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
